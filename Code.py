# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OziuNSLIEBP7JEfOBIdMif4sl49L6E9h
"""

import pandas as pd
import numpy as np
from datetime import datetime

# Function to read and load all required CSV files
def load_data():
    """
    Load all required CSV files for the analysis and perform necessary data preprocessing

    This function:
    1. Reads all CSV files from specified paths
    2. Handles data type conversions (strings to integers, strings to dates)
    3. Formats date columns appropriately for analysis

    Returns:
        tuple: Dataframes containing industry_client, subscription, payment, and financial data
    """
    # Loading the CSV files from the specified file paths
    industry_client_df = pd.read_csv('/content/industry_client_details.csv')
    subscription_df = pd.read_csv('/content/subscription_information.csv')
    payment_df = pd.read_csv('/content/payment_information.csv')
    financial_df = pd.read_csv('/content/finanical_information.csv')

    # Converting the 'renewed' column from string or boolean to integer (0 or 1)
    # This handles the case where the column might contain "True"/"False" strings or actual boolean values
    subscription_df['renewed'] = subscription_df['renewed'].astype(int)

    # Converting string date columns to datetime objects to enable date-based operations
    # This allows for date comparisons and filtering based on date ranges
    subscription_df['start_date'] = pd.to_datetime(subscription_df['start_date'])
    subscription_df['end_date'] = pd.to_datetime(subscription_df['end_date'])
    financial_df['start_date'] = pd.to_datetime(financial_df['start_date'])
    financial_df['end_date'] = pd.to_datetime(financial_df['end_date'])

    # Parsing payment dates which are in MM/DD/YYYY format
    # This ensures consistent date handling across all dataframes
    payment_df['payment_date'] = pd.to_datetime(payment_df['payment_date'], format='%m/%d/%Y')

    return industry_client_df, subscription_df, payment_df, financial_df

# Question 1: How many finance lending and blockchain clients does the organization have?
def count_finance_and_blockchain_clients(industry_client_df):
    """
    Count the number of Finance Lending and Blockchain clients

    This function:
    1. Filters the industry dataframe to find clients in specific industries
    2. Counts the number of clients in each category
    3. Calculates the total count of both industry types combined

    Args: industry_client_df (DataFrame): DataFrame containing client industry information

    Returns: tuple: Count of Finance Lending clients, Blockchain clients, and their total
    """
    # Count Finance Lending clients by filtering the dataframe for that specific industry value
    finance_lending_count = len(industry_client_df[industry_client_df['industry'] == 'Finance Lending'])

    # Count Blockchain clients, noting that they are labeled as 'Block Chain' in the dataset
    blockchain_count = len(industry_client_df[industry_client_df['industry'] == 'Block Chain'])

    # Calculate the combined total of both industry types
    total_count = finance_lending_count + blockchain_count

    return finance_lending_count, blockchain_count, total_count

# Question 2: Which industry in the organization has the highest renewal rate?
def find_highest_renewal_rate(industry_client_df, subscription_df):
    """
    Calculate renewal rates for each industry and find the one with the highest rate

    This function:
    1. Merges industry and subscription data on client_id
    2. Groups the data by industry and calculates renewal statistics
    3. Determines the renewal rate for each industry
    4. Identifies the industry with the highest renewal rate

    Args:
        industry_client_df (DataFrame): DataFrame containing client industry information
        subscription_df (DataFrame): DataFrame containing subscription renewal information

    Returns: tuple: Industry with highest renewal rate and its renewal rate percentage
    """
    # Merge the industry and subscription dataframes on client_id to connect renewal information with industries
    merged_df = pd.merge(industry_client_df, subscription_df, on='client_id')

    # Group by industry and calculate both the total count of subscriptions and sum of renewals
    # count = total number of subscriptions for the industry
    # sum = number of renewed subscriptions
    industry_renewal = merged_df.groupby('industry')['renewed'].agg(['count', 'sum'])

    # Calculate renewal rate (proportion of renewals) for each industry
    # Using apply with lambda to handle potential division by zero cases
    industry_renewal['renewal_rate'] = industry_renewal.apply(
        lambda x: x['sum'] / x['count'] if x['count'] > 0 else 0, axis=1)

    # Sort the industries by renewal rate in descending order to find the highest
    industry_renewal = industry_renewal.sort_values('renewal_rate', ascending=False)

    # Extract the industry with the highest renewal rate (first row after sorting)
    highest_industry = industry_renewal.index[0]

    # Convert the renewal rate to a percentage for better readability
    highest_rate = industry_renewal.iloc[0]['renewal_rate'] * 100

    return highest_industry, highest_rate

# Question 3: What was the average inflation rate when their subscriptions were renewed?
def calculate_average_inflation_rate(subscription_df, financial_df):
    """
    Calculate the average inflation rate at the time of subscription renewals

    This function:
    1. Filters subscriptions to only include those that were renewed
    2. For each renewal, finds the corresponding financial period
    3. Extracts the inflation rate at the time of renewal
    4. Calculates the average inflation rate across all renewals

    Args:
        subscription_df (DataFrame): DataFrame containing subscription information
        financial_df (DataFrame): DataFrame containing inflation rate data by time period

    Returns: float: Average inflation rate during subscription renewals
    """
    # Filter to only include subscriptions that were renewed (renewed = 1)
    renewed_subscriptions = subscription_df[subscription_df['renewed'] == 1]

    # Initialize an empty list to store the inflation rates for each renewal
    inflation_rates = []

    # For each renewed subscription, find the corresponding inflation rate
    for _, sub in renewed_subscriptions.iterrows():
        # Get the renewal date (which is the end date of the subscription)
        renewal_date = sub['end_date']

        # Find the financial period that contains this renewal date
        # A matching period is one where the renewal date falls between the start and end dates
        matching_period = financial_df[
            (financial_df['start_date'] <= renewal_date) &
            (financial_df['end_date'] >= renewal_date)
        ]

        # If a matching period was found, add its inflation rate to our list
        if not matching_period.empty:
            inflation_rates.append(matching_period.iloc[0]['inflation_rate'])

    # Calculate the average inflation rate, handling the case where no matches were found
    if inflation_rates:
        average_inflation = np.mean(inflation_rates)
    else:
        average_inflation = 0

    return average_inflation

# Question 4: What is the median amount paid each year for all payment methods?
def calculate_yearly_median_payments(payment_df):
    """
    Calculate the median payment amount for each year across all payment methods

    This function:
    1. Extracts the year from each payment date
    2. Groups payments by year
    3. Calculates the median payment amount for each year

    Args: payment_df (DataFrame): DataFrame containing payment information

    Returns: dict: Dictionary with years as keys and median payment amounts as values
    """
    # Extract the year component from each payment date to enable grouping by year
    payment_df['payment_year'] = payment_df['payment_date'].dt.year

    # Group payments by year and calculate the median amount for each year
    # The resulting dictionary will have years as keys and median amounts as values
    yearly_medians = payment_df.groupby('payment_year')['amount_paid'].median().to_dict()

    return yearly_medians

# Main function to run all analyses
def main():
    """
    Main execution function that:
    1. Loads all required data
    2. Performs analysis for each of the four questions
    3. Prints the results in a formatted way
    """
    # Load and preprocess all data files
    industry_client_df, subscription_df, payment_df, financial_df = load_data()

    # Question 1: Count finance lending and blockchain clients
    finance_count, blockchain_count, total_count = count_finance_and_blockchain_clients(industry_client_df)
    print(f"Question 1 Answer:")
    print(f"Total Finance Lending clients: {finance_count}")
    print(f"Total Blockchain clients: {blockchain_count}")
    print(f"Total Finance Lending and Blockchain clients: {total_count}")

    # Question 2: Find industry with highest renewal rate
    highest_industry, highest_rate = find_highest_renewal_rate(industry_client_df, subscription_df)
    print(f"\nQuestion 2 Answer:")
    print(f"Industry with highest renewal rate: {highest_industry} with {highest_rate:.2f}%")

    # Question 3: Calculate average inflation rate during renewals
    avg_inflation = calculate_average_inflation_rate(subscription_df, financial_df)
    print(f"\nQuestion 3 Answer:")
    print(f"Average inflation rate during renewals: {avg_inflation:.2f}%")

    # Question 4: Calculate median yearly payments
    yearly_medians = calculate_yearly_median_payments(payment_df)
    print(f"\nQuestion 4 Answer:")
    print("Median amount paid each year for all payment methods:")
    # Sort years chronologically before printing for better readability
    for year, median in sorted(yearly_medians.items()):
        print(f"{year}: ${median:.2f}")

# Standard boilerplate to call the main function
if __name__ == "__main__":
    main()